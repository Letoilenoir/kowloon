import mongoose from "mongoose";
import User from "./User.js";
import Settings from "./Settings.js";
import Post from "./Post.js";
import Circle from "./Circle.js";
import Group from "./Group.js";
import Bookmark from "./Bookmark.js";
import Like from "./Like.js";
import tensify from "tensify";
import crypto from "crypto";
const Schema = mongoose.Schema;
const ObjectId = mongoose.Types.ObjectId;

const ActivitySchema = new Schema(
  {
    id: { type: String, key: true }, // This is different from the _id, this is the global UUID of the activity.
    actorId: { type: String, required: true }, // The actor ID of the activity's author. Required.
    type: { type: String, default: "Create" },
    object: { type: Object, default: undefined }, // The object of the Activity.
    objectType: { type: String, default: undefined }, // This should be the same as the collection name, i.e. Post, Like, Circle, etc.
    objectId: { type: String, default: undefined }, // The ID of the activity's object (if it's a Post, Like, Circle or other created or modified thing)
    target: { type: String, default: undefined }, // If this activity targets another object, this is the ID of that object (if it's a like or a reply, for example)
    to: { type: [String], default: undefined }, // This is for tagging users (if post is visible to them or public)
    bto: { type: [String], default: undefined }, // This is for private messages
    cc: { type: [String], default: undefined }, // This is where Group IDs go if a post is meant to be sent to a group
    bcc: { type: [String], default: undefined }, // This is where Circle IDs go if a post is only visible to certain circles
    summary: { type: String, default: undefined }, // A summary of the activity generated by the user/app or by the system if none is provided
    public: { type: Boolean, default: false }, // Is the post visible to the public (via the Web or apps) or not?
    replies: { type: Object, default: false }, // This can be either false (for no replies at all), true (for public replies) or an array of circle IDs that can reply to this post
    flagged: { type: Object, default: false }, // Has this post been flagged? If so, it'll include a reason, who flagged it and when.
    deletedAt: { type: Date, default: null }, // If the post is deleted, when it was deleted
    deletedBy: { type: String, default: null }, // If the post is deleted, who deleted it (usually the user unless an admin does it)
    signature: Buffer, // The signature of the activity generated by signing the object with the actor's private key
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

ActivitySchema.virtual("actor", {
  ref: "User",
  localField: "actorId",
  foreignField: "id",
  justOne: true,
});

ActivitySchema.virtual("likes", {
  ref: "Like",
  localField: "id",
  foreignField: "target",
});

ActivitySchema.pre("save", async function (next) {
  // Create the activity id and url
  const domain = (await Settings.findOne({ name: "domain" })).value;

  this.id = this.id || `activity:${this._id}@${domain}`;
  this.url = this.url || `//${domain}/activities/${this._id}`;
  //

  let actor = await User.findOne({ id: this.actorId }); // Retrieve the activity actor

  // Sign this activity using the user's private key if it's not signed
  let stringject = Buffer.from(this.id);
  const sign = crypto.createSign("RSA-SHA256");
  sign.update(stringject);
  this.signature = sign.sign(actor.keys.private, "base64");
  //

  // Generate an activity summar if none is provided
  if (!this.summary || this.summary === "") {
    // If there's no summary for this activity provided
    this.summary = `${actor?.username} ${
      tensify(this.type.toLowerCase()).past
    } ${"aeiouAEIOU".indexOf(this.type[0]) !== -1 ? "an" : "a"} ${
      this.type === "Create" ? "new " : ""
    }${this.objectType}${
      this.object?.title ? ': "' + this.object.title + '"' : ""
    }`; // ie 'Bob Smith created a new Note: "Hello world!"' or 'Susan Jones liked an Activity'
  }
  //

  // Now let's do the complicated stuff
  if (this.$isNew) {
    switch (this.type) {
      // If they're creating a thing

      case "Create":
        switch (this.objectType) {
          // If it's a Post

          case "Post":
            this.object = {
              ...this.object,
              actorId: this.object.actorId || this.actorId,
              to: this.object.to || this.to,
              bto: this.object.bto || this.bto,
              cc: this.object.cc || this.cc,
              bcc: this.object.bcc || this.bcc,
            };
            if (this.object.circles && this.object.circles.length > 0) {
              this.public = false;
              this.object.public = false;
            }

            const post = await Post.create(this.object);
            this.objectId = post.id;
            break;

          // If it's a Circle
          case "Circle":
            this.object = {
              ...this.object,
              actorId: this.object.actorId || this.actorId,
            };
            const circle = await Circle.create(this.object);
            this.objectId = circle.id;
            break;

          // If it's a Group
          case "Group":
            this.object = {
              ...this.object,
              actorId: this.actorId,
            };
            const group = await Group.create(this.object);
            this.objectId = group.id;
            break;

          case "Bookmark":
            this.object = {
              ...this.object,
              actorId: this.actorId,
            };
            const bookmark = await Bookmark.create(this.object);
            this.objectId = bookmark.id;
            break;
        }
        break;

      // If it's an update
      case "Update":
        switch (this.objectType) {
          case "Post":
            let originalPost = await Post.findOne({ id: this.target });
            if (originalPost) {
              await Post.findOneAndUpdate(
                { id: this.target },
                { $set: this.object }
              );
            }
            break;
          case "Circle":
            let originalCircle = await Circle.findOne({ id: this.target });
            if (originalCircle && originalCircle.actor == this.actorId) {
              originalCircle = { ...originalCircle, ...this.object };
              await Circle.findOneAndUpdate(
                { id: this.target },
                { $set: this.object }
              );
            }
            break;
          case "Group":
            let originalGroup = await Group.findOne({ id: this.target });
            if (originalGroup && originalGroup.admins.includes(this.actorId)) {
              await Group.findOneAndUpdate(
                { id: this.target },
                { $set: this.object }
              );
            }
            break;
        }
        break;

      // Deleting a thing
      case "Delete":
        switch (this.objectType) {
          case "Post":
            await Post.findOneAndUpdate(
              { id: this.objectId, actorId: this.actorId },
              { deletedAt: new Date(), deletedBy: this.actorId }
            );
            break;
          case "Circle":
            await Circle.findOneAndUpdate(
              { id: this.objectId, actorId: this.actorId },
              { deletedAt: new Date(), deletedBy: this.actorId }
            );
            break;
          case "Group":
            await Group.findOneAndUpdate(
              { id: this.objectId, admins: this.actorId },
              { deletedAt: new Date(), deletedBy: this.actorId }
            );
            break;
          case "Bookmark":
            await Bookmark.findOneAndUpdate(
              { id: this.objectId, actorId: this.actorId },
              { deletedAt: new Date() }
            );
            break;
        }
        break;

      // Add something to another thing
      case "Add":
        switch (this.objectType) {
          case "Circle":
            await Circle.findOneAndUpdate(
              { id: this.target, actorId: this.actorId },
              { $push: { members: this.object } }
            );
            break;
          case "Group":
            await Group.findOneAndUpdate(
              { id: this.target, admins: this.actorId },
              { $push: { members: this.object } }
            );
            break;
        }
        break;

      // Remove something from another thing
      case "Remove":
        switch (this.objectType) {
          case "Circle":
            await Circle.findOneAndUpdate(
              { id: this.target, actorId: this.actorId },
              { $pull: { members: this.object } }
            );
            break;
          case "Group":
            await Group.findOneAndUpdate(
              { id: this.target, admins: this.actorId },
              { $pull: { members: this.object } }
            );
            break;
        }
        break;
      case "Like":
        let liked = await Like.create({
          target: this.object.target,
          actorId: this.actorId,
          type: this.object.type,
        });
        this.objectId = liked.id;
        break;
      case "Unlike":
        await Like.deleteMany({
          target: this.target,
          actorId: this.actorId,
          type: this.object.type,
        });
        break;
      case "Bookmark":
        let bookmark = await Bookmark.create({
          public: this.public,
          target: this.target,
          actorId: this.actorId,
          href: this.object.href,
          tags: this.object.tags,
          title: this.object.title,
          summary: this.object.summary,
          image: this.object.image,
        });
        this.objectId = bookmark.id;
        break;
      case "Unbookmark":
        await Bookmark.deleteMany({
          target: this.target,
          actorId: this.actorId,
        });
        break;
      case "Follow":
        await User.findOneAndUpdate(
          {
            id: this.actorId,
          },
          {
            $push: {
              following: this.target,
            },
          }
        );
        break;
      case "Unfollow":
        await User.findOneAndUpdate(
          {
            id: this.actorId,
          },
          {
            $pull: {
              following: this.target,
            },
          }
        );
        break;
    }
  }

  next();
});

ActivitySchema.methods.verifySignature = async function () {
  let actor = await User.findOne({ id: this.actorId }); // Retrieve the activity actor
  let stringject = Buffer.from(JSON.stringify(this.id));
  return crypto.verify(
    "RSA-SHA256",
    stringject,
    actor.keys.public,
    this.signature
  );
};

export default mongoose.model("Activity", ActivitySchema);
